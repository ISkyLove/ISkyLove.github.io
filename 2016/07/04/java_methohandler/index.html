<!DOCTYPE html>
<html >
<head>
  <meta charset="utf-8">
  
  <title>java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记） | 剑客爱编程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="随着JDK 7 的发布，字节码指令集新添加一位新成员—-invokeddynamic，便于JDK 7 支持动态类型语言，配套的程序包是新加入了java.lang.invoke,该包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法以外提供一种新的动态确定目标方法的机制，称为MethodHande。该机制简单来说，更好地解决java语言无法单独把一个函数作为参数进行传递，而普遍的做法就是设计一个">
<meta property="og:type" content="article">
<meta property="og:title" content="java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）">
<meta property="og:url" content="https://iskylove.github.io/2016/07/04/java_methohandler/index.html">
<meta property="og:site_name" content="剑客爱编程">
<meta property="og:description" content="随着JDK 7 的发布，字节码指令集新添加一位新成员—-invokeddynamic，便于JDK 7 支持动态类型语言，配套的程序包是新加入了java.lang.invoke,该包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法以外提供一种新的动态确定目标方法的机制，称为MethodHande。该机制简单来说，更好地解决java语言无法单独把一个函数作为参数进行传递，而普遍的做法就是设计一个">
<meta property="og:updated_time" content="2016-07-04T13:00:36.114Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）">
<meta name="twitter:description" content="随着JDK 7 的发布，字节码指令集新添加一位新成员—-invokeddynamic，便于JDK 7 支持动态类型语言，配套的程序包是新加入了java.lang.invoke,该包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法以外提供一种新的动态确定目标方法的机制，称为MethodHande。该机制简单来说，更好地解决java语言无法单独把一个函数作为参数进行传递，而普遍的做法就是设计一个">
  
    <link rel="alternative" href="/atom.xml" title="剑客爱编程" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xtazt.com1.z0.glb.clouddn.com/blog_headhead_small.jpg">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/orange/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://7xtazt.com1.z0.glb.clouddn.com/blog_headhead.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">剑客爱编程</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aath/">aath</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adnroid/">adnroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/all/">all</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/alogorithm/">alogorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animation/">animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animator/">animator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apktool/">apktool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/broadcast/">broadcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decompile/">decompile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dex2jar/">dex2jar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jd-gui/">jd-gui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-native/">react native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svnchecker/">svnchecker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心灵鸡汤/">心灵鸡汤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经验/">经验</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/ISkyLove">GitHub</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/jiankeaibiancheng/">博客园</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">武林至尊，宝刀屠龙，号令天下，莫敢不从，倚天不出，谁与争锋？</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">剑客爱编程</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://7xtazt.com1.z0.glb.clouddn.com/blog_headhead.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">剑客爱编程</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-java_methohandler" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/04/java_methohandler/" class="article-date">
      <time datetime="2016-07-04T13:00:36.262Z" itemprop="datePublished">2016-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/java/">java</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>随着JDK 7 的发布，字节码指令集新添加一位新成员—-invokeddynamic，便于JDK 7 支持<strong>动态类型语言</strong>，配套的程序包是新加入了java.lang.invoke,该包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法以外提供一种新的动态确定目标方法的机制，称为<strong>MethodHande</strong>。该机制简单来说，更好地解决java语言无法单独把一个函数作为参数进行传递，而普遍的做法就是设计一个interface接口，以实现这个接口的对象作为参数传进去。不过，拥有Method Handle之后，可以更简单.<a id="more"></a></p>
<h5 id="方法句柄的类型"><a href="#方法句柄的类型" class="headerlink" title="方法句柄的类型"></a><strong>方法句柄的类型</strong></h5><p>对于一个方法句柄来说，它的类型完全由它的参数类型和返回值类型来确定，而与它所引用的底层方法的名称和所在的类没有关系。比如引用String类的length方法和Integer类的intValue方法的方法句柄的类型就是一样的，因为这两个方法都没有参数，而且返回值类型都是int。</p>
<p>在得到一个方法句柄，即MethodHandle类的对象之后，可以通过其type方法来查看其类型。该方法的返回值是一个java.lang.invoke.MethodType类的对象。MethodType类的所有对象实例都是不可变的，类似于String类。所有对MethodType类对象的修改，都会产生一个新的MethodType类对象。两个MethodType类对象是否相等，只取决于它们所包含的参数类型和返回值类型是否完全一致。</p>
<p>MethodType类的对象实例只能通过MethodType类中的静态工厂方法来创建。这样的工厂方法有三类。第一类是通过指定参数和返回值的类型来创建MethodType，这主要是使用methodType方法的多种重载形式。使用这些方法的时候，至少需要指定返回值类型，而参数类型则可以是0到多个。返回值类型总是出现在methodType方法参数列表的第一个，后面紧接着的是0到多个参数的类型。类型都是由Class类的对象来指定的。如果返回值类型是void，可以用void.class或java.lang.Void.class来声明。代码清单2-31中给出了使用methodType方法的几个示例。每个MethodType声明上以注释的方式给出了与之相匹配的String类中的一个方法。这里值得一提的是，最后一个methodType方法调用中使用了另外一个MethodType的参数类型作为当前MethodType类对象的参数类型。<br>MethodType类中的methodType方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateMethodTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String.length()</span></span><br><span class="line">    MethodType mt1 = MethodType.methodType(<span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//String.concat(String str)</span></span><br><span class="line">    MethodType mt2 = MethodType.methodType(String.class, String.class);</span><br><span class="line">    <span class="comment">//String.getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</span></span><br><span class="line">    MethodType mt3 = MethodType.methodType(<span class="keyword">void</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">char</span>[].class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//String.startsWith(String prefix)</span></span><br><span class="line">    MethodType mt4 = MethodType.methodType(<span class="keyword">boolean</span>.class, mt2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了显式地指定返回值和参数的类型之外，还可以生成通用的MethodType类型，即返回值和所有参数的类型都是Object类。这是通过静态工厂方法genericMethodType来创建的。方法genericMethodType有两种重载形式：第一种形式只需要指明方法类型中包含的Object类型的参数个数即可，而第二种形式可以提供一个额外的参数来说明是否在参数列表的后面添加一个Object[]类型的参数。在代码清单2-32中，mt1有3个类型为Object的参数，而mt2有2个类型为Object的参数和后面的Object[]类型参数。<br>生成通用MethodType类型的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateGenericMethodTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MethodType mt1 = MethodType.genericMethodType(<span class="number">3</span>);</span><br><span class="line">    MethodType mt2 = MethodType.genericMethodType(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后介绍的一个工厂方法是比较复杂的fromMethodDescriptorString。这个方法允许开发人员指定方法类型在字节代码中的表示形式作为创建MethodType时的参数。这个方法的复杂之处在于字节代码中的方法类型格式不是很好理解。比如以下代码清单中的String.getChars方法的类型在字节代码中的表示形式是“(II[CI)V”。不过这种格式比逐个声明返回值和参数类型的做法更加简洁，适合于对Java字节代码格式比较熟悉的开发人员。在代码清单中，“(Ljava/lang/String;)Ljava/lang/String;”所表示的方法类型是返回值和参数类型都是java.lang.String，相当于使用MethodType.methodType(String.class, String.class)。<br>使用方法类型在字节代码中的表示形式来创建MethodType<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateMethodTypesFromDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    String descriptor = <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>;</span><br><span class="line">    MethodType mt1 = MethodType.fromMethodDescriptorString(descriptor, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用fromMethodDescriptorString方法的时候，需要指定一个类加载器。该类加载器用来加载方法类型表达式中出现的Java类。如果不指定，默认使用系统类加载器。</p>
<p>在通过工厂方法创建出MethodType类的对象实例之后，可以对其进行进一步修改。这些修改都围绕返回值和参数类型展开。所有这些修改方法都返回另外一个新的MethodType对象。代码清单2-34给出了对MethodType中的返回值和参数类型进行修改的示例代码。基本的修改操作包括改变返回值类型、添加和插入新参数、删除已有参数和修改已有参数的类型等。在每个修改方法上以注释形式给出修改之后的类型，括号里面是参数类型列表，外面是返回值类型。<br>对MethodType中的返回值和参数类型进行修改的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMethodType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(int,int)String</span></span><br><span class="line">    MethodType mt = MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//(int,int,float)String</span></span><br><span class="line">    mt = mt.appendParameterTypes(<span class="keyword">float</span>.class);</span><br><span class="line">    <span class="comment">//(int,double,long,int,float)String</span></span><br><span class="line">    mt = mt.insertParameterTypes(<span class="number">1</span>, <span class="keyword">double</span>.class, <span class="keyword">long</span>.class);</span><br><span class="line">    <span class="comment">//(int,double,int,float)String</span></span><br><span class="line">    mt = mt.dropParameterTypes(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//(int,double,String,float)String</span></span><br><span class="line">    mt = mt.changeParameterType(<span class="number">2</span>, String.class);</span><br><span class="line">    <span class="comment">//(int,double,String,float)void</span></span><br><span class="line">    mt = mt.changeReturnType(<span class="keyword">void</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面这几个精确修改返回值和参数的类型的方法之外，MethodType还有几个可以一次性对返回值和所有参数的类型进行处理的方法。代码清单2-35给出了这几个方法的使用示例，其中wrap和unwrap用来在基本类型及其包装类型之间进行转换，generic方法把所有返回值和参数类型都变成Object类型，而erase只把引用类型变成Object，并不处理基本类型。修改之后的方法类型同样以注释的形式给出。<br>一次性修改MethodType中的返回值和所有参数的类型的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapAndGeneric</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(int,double)Integer</span></span><br><span class="line">    MethodType mt = MethodType.methodType(Integer.class, <span class="keyword">int</span>.class, <span class="keyword">double</span>.class);</span><br><span class="line">    <span class="comment">//(Integer,Double)Integer</span></span><br><span class="line">    MethodType wrapped = mt.wrap();</span><br><span class="line">    <span class="comment">//(int,double)int</span></span><br><span class="line">    MethodType unwrapped = mt.unwrap();</span><br><span class="line">    <span class="comment">//(Object,Object)Object</span></span><br><span class="line">    MethodType generic = mt.generic();</span><br><span class="line">    <span class="comment">//(int,double)Object</span></span><br><span class="line">    MethodType erased = mt.erase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于每个对MethodType对象进行修改的方法的返回值都是一个新的MethodType对象，可以很容易地通过方法级联来简化代码。</p>
<h5 id="方法句柄的调用"><a href="#方法句柄的调用" class="headerlink" title="方法句柄的调用"></a>方法句柄的调用</h5><p>在获取到了一个方法句柄之后，最直接的使用方法就是调用它所引用的底层方法。在这点上，方法句柄的使用类似于反射API中的Method类。但是方法句柄在调用时所提供的灵活性是Method类中的invoke方法所不能比的。</p>
<p>最直接的调用一个方法句柄的做法是通过invokeExact方法实现的。这个方法与直接调用底层方法是完全一样的。invokeExact方法的参数依次是作为方法接收者的对象和调用时候的实际参数列表。比如在一下代码清单中，先获取String类中substring的方法句柄，再通过invokeExact来进行调用。这种调用方式就相当于直接调用”Hello World”.substring(1, 3)。<br>使用invokeExact方法调用方法句柄<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeExact</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(String.class, <span class="string">"substring"</span>, type);</span><br><span class="line">    String str = (String) mh.invokeExact(<span class="string">"Hello World"</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里强调一下静态方法和一般方法之间的区别。静态方法在调用时是不需要指定方法的接收对象的，而一般的方法则是需要的。如果方法句柄mh所引用的是java.lang.Math类中的静态方法min，那么直接通过mh.invokeExact(3, 4)就可以调用该方法。</p>
<p>注意　invokeExact方法在调用的时候要求严格的类型匹配，方法的返回值类型也是在考虑范围之内的。以上代码清单中的方法句柄所引用的substring方法的返回值类型是String，因此在使用invokeExact方法进行调用时，需要在前面加上强制类型转换，以声明返回值的类型。如果去掉这个类型转换，而直接赋值给一个Object类型的变量，在调用的时候会抛出异常，因为invokeExact会认为方法的返回值类型是Object。去掉类型转换但是不进行赋值操作也是错误的，因为invokeExact会认为方法的返回值类型是void，也不同于方法句柄要求的String类型的返回值。</p>
<p>与invokeExact所要求的类型精确匹配不同的是，invoke方法允许更加松散的调用方式。它会尝试在调用的时候进行返回值和参数类型的转换工作。这是通过MethodHandle类的asType方法来完成的。asType方法的作用是把当前的方法句柄适配到新的MethodType上，并产生一个新的方法句柄。当方法句柄在调用时的类型与其声明的类型完全一致的时候，调用invoke等同于调用invokeExact；否则，invoke会先调用asType方法来尝试适配到调用时的类型。如果适配成功，调用可以继续；否则会抛出相关的异常。这种灵活的适配机制，使invoke方法成为在绝大多数情况下都应该使用的方法句柄调用方式。</p>
<p>进行类型适配的基本规则是比对返回值类型和每个参数的类型是否都可以相互匹配。只要返回值类型或某个参数的类型无法完成匹配，那么整个适配过程就是失败的。从待转换的源类型S到目标类型T匹配成功的基本原则如下：</p>
<p>1）可以通过Java的类型转换来完成，一般是从子类转换成父类，接口的实现类转换成接口，比如从String类转换到Object类。</p>
<p>2）可以通过基本类型的转换来完成，只能进行类型范围的扩大，比如从int类型转换到long类型。</p>
<p>3）可以通过基本类型的自动装箱和拆箱机制来完成，比如从int类型到Integer类型。</p>
<p>4）如果S有返回值类型，而T的返回值是void，S的返回值会被丢弃。</p>
<p>5）如果S的返回值是void，而T的返回值是引用类型，T的返回值会是null。</p>
<p>6）如果S的返回值是void，而T的返回值是基本类型，T的返回值会是0。</p>
<p>满足上面规则时进行两个方法类型之间的转换是会成功的。对于invoke方法的具体使用，只需要把代码清单2-36中的invokeExact方法换成invoke即可，并不需要做太多的介绍。</p>
<p>最后一种调用方式是使用invokeWithArguments。该方法在调用时可以指定任意多个Object类型的参数。完整的调用方式是首先根据传入的实际参数的个数，通过MethodType的genericMethodType方法得到一个返回值和参数类型都是Object的新方法类型。再把原始的方法句柄通过asType转换后得到一个新的方法句柄。最后通过新方法句柄的invokeExact方法来完成调用。这个方法相对于invokeExact和invoke的优势在于，它可以通过Java反射API被正常获取和调用，而invokeExact和invoke不可以这样。它可以作为反射API和方法句柄之间的桥梁。</p>
<h5 id="参数长度可变的方法句柄"><a href="#参数长度可变的方法句柄" class="headerlink" title="参数长度可变的方法句柄"></a>参数长度可变的方法句柄</h5><p>在方法句柄中，所引用的底层方法中包含长度可变的参数是一种比较特殊的情况。虽然最后一个长度可变的参数实际上是一个数组，但是仍然可以简化方法调用时的语法。对于这种特殊的情况，方法句柄也提供了相关的处理能力，主要是一些转换的方法，允许在可变长度的参数和数组类型的参数之间互相转换，以方便开发人员根据需求选择最适合的调用语法。</p>
<p>MethodHandle中第一个与长度可变参数相关的方法是asVarargsCollector。它的作用是把原始的方法句柄中的最后一个数组类型的参数转换成对应类型的可变长度参数。如代码清单2-37所示，方法normalMethod的最后一个参数是int类型的数组，引用它的方法句柄在通过asVarargsCollector方法转换之后，得到的新方法句柄在调用时就可以使用长度可变参数的语法格式，而不需要使用原始的数组形式。在实际的调用中，int类型的参数3、4和5组成的数组被传入到了normalMethod的参数args中。<br>asVarargsCollector方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">(String arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span>[] arg3)</span> </span>&#123;   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asVarargsCollector</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(Varargs.class, <span class="string">"normalMethod"</span>, MethodType.methodType(<span class="keyword">void</span>.class, String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>[].class));</span><br><span class="line">    mh = mh.asVarargsCollector(<span class="keyword">int</span>[].class);</span><br><span class="line">    mh.invoke(<span class="keyword">this</span>, <span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个方法asCollector的作用与asVarargsCollector类似，不同的是该方法只会把指定数量的参数收集到原始方法句柄所对应的底层方法的数组类型参数中，而不像asVarargsCollector那样可以收集任意数量的参数。如代码清单2-38所示，还是以引用normalMethod的方法句柄为例，asCollector方法调用时的指定参数为2，即只有2个参数会被收集到整数类型数组中。在实际的调用中，int类型的参数3和4组成的数组被传入到了normalMethod的参数args中。<br>asCollector方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asCollector</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(Varargs.class, <span class="string">"normalMethod"</span>, MethodType.methodType(<span class="keyword">void</span>.class, String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>[].class));</span><br><span class="line">    mh = mh.asCollector(<span class="keyword">int</span>[].class, <span class="number">2</span>);</span><br><span class="line">    mh.invoke(<span class="keyword">this</span>, <span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的两个方法把数组类型参数转换为长度可变的参数，自然还有与之对应的执行反方向转换的方法。代码清单给出的asSpreader方法就把长度可变的参数转换成数组类型的参数。转换之后的新方法句柄在调用时使用数组作为参数，而数组中的元素会被按顺序分配给原始方法句柄中的各个参数。在实际的调用中，toBeSpreaded方法所接受到的参数arg2、arg3和arg4的值分别是3、4和5.<br>asSpreader方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toBeSpreaded</span><span class="params">(String arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3, <span class="keyword">int</span> arg4)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asSpreader</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(Varargs.class, <span class="string">"toBeSpreaded"</span>, MethodType.methodType(<span class="keyword">void</span>.class, String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br><span class="line">    mh = mh.asSpreader(<span class="keyword">int</span>[].class, <span class="number">3</span>);</span><br><span class="line">    mh.invoke(<span class="keyword">this</span>, <span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个方法asFixedArity是把参数长度可变的方法转换成参数长度不变的方法。经过这样的转换之后，最后一个长度可变的参数实际上就变成了对应的数组类型。在调用方法句柄的时候，就只能使用数组来进行参数传递。如代码清单所示，asFixedArity会把引用参数长度可变方法varargsMethod的原始方法句柄转换成固定长度参数的方法句柄。<br>asFixedArity方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">varargsMethod</span><span class="params">(String arg1, <span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asFixedArity</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(Varargs.class, <span class="string">"varargsMethod"</span>, MethodType.methodType(<span class="keyword">void</span>.class, String.class, <span class="keyword">int</span>[].class));</span><br><span class="line">    mh = mh.asFixedArity();</span><br><span class="line">    mh.invoke(<span class="keyword">this</span>, <span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h5><p>在前面介绍过，如果方法句柄在调用时引用的底层方法不是静态的，调用的第一个参数应该是该方法调用的接收者。这个参数的值一般在调用时指定，也可以事先进行绑定。通过MethodHandle的bindTo方法可以预先绑定底层方法的调用接收者，而在实际调用的时候，只需要传入实际参数即可，不需要再指定方法的接收者。代码清单给出了对引用String类的length方法的方法句柄的两种调用方式：第一种没有进行绑定，调用时需要传入length方法的接收者；第二种方法预先绑定了一个String类的对象，因此调用时不需要再指定。<br>参数绑定的基本用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindTo</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(String.class, <span class="string">"length"</span>, MethodType.methodType(<span class="keyword">int</span>.class));</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) mh.invoke(<span class="string">"Hello"</span>); <span class="comment">//值为5</span></span><br><span class="line">    mh = mh.bindTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    len = (<span class="keyword">int</span>) mh.invoke(); <span class="comment">//值为11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种预先绑定参数的方式的灵活性在于它允许开发人员只公开某个方法，而不公开该方法所在的对象。开发人员只需要找到对应的方法句柄，并把适合的对象绑定到方法句柄上，客户代码就可以只获取到方法本身，而不会知道包含此方法的对象。绑定之后的方法句柄本身就可以在任何地方直接运行。</p>
<p>实际上，MethodHandle的bindTo方法只是绑定方法句柄的第一个参数而已，并不要求这个参数一定表示方法调用的接收者。对于一个MethodHandle，可以多次使用bindTo方法来为其中的多个参数绑定值。代码清单2-42给出了多次绑定的一个示例。方法句柄所引用的底层方法是String类中的indexOf方法，同时为方法句柄的前两个参数分别绑定了具体的值。<br>多次参数绑定的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multipleBindTo</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(String.class, <span class="string">"indexOf"</span>,</span><br><span class="line">    MethodType.methodType(<span class="keyword">int</span>.class, String.class, <span class="keyword">int</span>.class));</span><br><span class="line">    mh = mh.bindTo(<span class="string">"Hello"</span>).bindTo(<span class="string">"l"</span>);</span><br><span class="line">    System.out.println(mh.invoke(<span class="number">2</span>)); <span class="comment">//值为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，在进行参数绑定的时候，只能对引用类型的参数进行绑定。无法为int和float这样的基本类型绑定值。对于包含基本类型参数的方法句柄，可以先使用wrap方法把方法类型中的基本类型转换成对应的包装类，再通过方法句柄的asType将其转换成新的句柄。转换之后的新句柄就可以通过bindTo来进行绑定.<br>基本类型参数的绑定方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mh = lookup.findVirtual(String.class, <span class="string">"substring"</span>, MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br><span class="line">mh = mh.asType(mh.type().wrap());</span><br><span class="line">mh = mh.bindTo(<span class="string">"Hello World"</span>).bindTo(<span class="number">3</span>);</span><br><span class="line">System.out.println(mh.invoke(<span class="number">5</span>)); <span class="comment">//值为“lo”</span></span><br></pre></td></tr></table></figure></p>
<h5 id="获取方法句柄"><a href="#获取方法句柄" class="headerlink" title="获取方法句柄"></a>获取方法句柄</h5><p>获取方法句柄最直接的做法是从一个类中已有的方法中转换而来，得到的方法句柄直接引用这个底层方法。在之前的示例中都是通过这种方式来获取方法句柄的。方法句柄可以按照与反射API类似的做法，从已有的类中根据一定的条件进行查找。与反射API不同的是，方法句柄并不区分构造方法、方法和域，而是统一转换成MethodHandle对象。对于域来说，获取到的是用来获取和设置该域的值的方法句柄。</p>
<p>方法句柄的查找是通过java.lang.invoke.MethodHandles.Lookup类来完成的。在查找之前，需要通过调用MethodHandles.lookup方法获取到一个MethodHandles.Lookup类的对象。MethodHandles.Lookup类提供了一些方法以根据不同的条件进行查找。代码清单2-44以String类为例说明了查找构造方法和一般方法的示例。方法findConstructor用来查找类中的构造方法，需要指定返回值和参数类型，即MethodType对象。而findVirtual和findStatic则用来查找一般方法和静态方法，除了表示方法的返回值和参数类型的MethodType对象之外，还需要指定方法的名称。<br>查找构造方法、一般方法和静态方法的方法句柄的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookupMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    lookup.findConstructor(String.class, MethodType.methodType(<span class="keyword">void</span>.class, <span class="keyword">byte</span>[].class));</span><br><span class="line">    <span class="comment">//String.substring</span></span><br><span class="line">    lookup.findVirtual(String.class, <span class="string">"substring"</span>, MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br><span class="line">    <span class="comment">//String.format</span></span><br><span class="line">    lookup.findStatic(String.class, <span class="string">"format"</span>, MethodType.methodType(String.class, String.class, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面3种类型的方法之外，还有一个findSpecial方法用来查找类中的特殊方法，主要是类中的私有方法。代码清单2-45给出了findSpecial的使用示例，Method-HandleLookup是lookupSpecial方法所在的类，而privateMethod是该类中的一个私有方法。由于访问的是类的私有方法，从访问控制的角度出发，进行方法查找的类需要具备访问私有方法的权限。<br>查找类中特殊方法的方法句柄的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodHandle <span class="title">lookupSpecial</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findSpecial(MethodHandleLookup.class, <span class="string">"privateMethod"</span>, MethodType.methodType(<span class="keyword">void</span>.class), MethodHandleLookup.class);</span><br><span class="line">    <span class="keyword">return</span> mh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，findSpecial方法比之前的findVirtual和findStatic等方法多了一个参数。这个额外的参数用来指定私有方法被调用时所使用的类。提供这个类的原因是为了满足对私有方法的访问控制的要求。当方法句柄被调用时，指定的调用类必须具备访问私有方法的权限，否则会出现无法访问的错误。</p>
<p>除了类中本来就存在的方法之外，对域的处理也是通过相应的获取和设置域的值的方法句柄来完成的。代码清单说明了如何查找到类中的静态域和一般域所对应的获取和设置的方法句柄。在查找的时候只需要提供域所在的类的Class对象、域的名称和类型即可。<br>查找类中的静态域和一般域对应的获取和设置的方法句柄的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookupFieldAccessor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, Illegal-AccessException</span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    lookup.findGetter(Sample.class, <span class="string">"name"</span>, String.class);</span><br><span class="line">    lookup.findSetter(Sample.class, <span class="string">"name"</span>, String.class);</span><br><span class="line">    lookup.findStaticGetter(Sample.class, <span class="string">"value"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    lookup.findStaticSetter(Sample.class, <span class="string">"value"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于静态域来说，调用其对应的获取和设置值的方法句柄时，并不需要提供调用的接收者对象作为参数。而对于一般域来说，该对象在调用时是必需的。</p>
<p>除了直接在某个类中进行查找之外，还可以从通过反射API得到的Constructor、Field和Method等对象中获得方法句柄。如代码清单2-47所示，首先通过反射API得到表示构造方法的Constructor对象，再通过unreflectConstructor方法就可以得到其对应的一个方法句柄；而通过unreflect方法可以将Method类对象转换成方法句柄。对于私有方法，则需要使用unreflectSpecial来进行转换，同样也需要提供一个作用与findSpecial中参数相同的额外参数；对于Field类的对象来说，通过unreflectGetter和unreflectSetter就可以得到获取和设置其值的方法句柄。<br>通过反射API获取方法句柄的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unreflect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    Constructor constructor = String.class.getConstructor(<span class="keyword">byte</span>[].class);</span><br><span class="line">    lookup.unreflectConstructor(constructor);</span><br><span class="line">    Method method = String.class.getMethod(<span class="string">"substring"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    lookup.unreflect(method);</span><br><span class="line">       </span><br><span class="line">    Method privateMethod = ReflectMethodHandle.class.getDeclaredMethod(<span class="string">"privateMethod"</span>);</span><br><span class="line">    lookup.unreflectSpecial(privateMethod, ReflectMethodHandle.class);</span><br><span class="line">       </span><br><span class="line">    Field field = ReflectMethodHandle.class.getField(<span class="string">"name"</span>);</span><br><span class="line">    lookup.unreflectGetter(field);</span><br><span class="line">    lookup.unreflectSetter(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了通过在Java类中进行查找来获取方法句柄外，还可以通过java.lang.invoke.MethodHandles中提供的一些静态工厂方法来创建一些通用的方法句柄。</p>
<p>第一个方法是用来对数组进行操作的，即得到可以用来获取和设置数组中元素的值的方法句柄。这些工厂方法的作用等价反射API中的java.lang.reflect.Array类中的静态方法。如代码清单所示，MethodHandles的arrayElementGetter和arrayElementSetter方法分别用来得到获取和设置数组元素的值的方法句柄。调用这些方法句柄就可以对数组进行操作。<br>获取和设置数组中元素的值的方法句柄的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayHandles</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    MethodHandle setter = MethodHandles.arrayElementSetter(<span class="keyword">int</span>[].class);</span><br><span class="line">    setter.invoke(array, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">    MethodHandle getter = MethodHandles.arrayElementGetter(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">int</span> value = (<span class="keyword">int</span>) getter.invoke(array, <span class="number">3</span>); <span class="comment">//值为6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MethodHandles中的静态方法identity的作用是通过它所生成的方法句柄，在每次调用的时候，总是返回其输入参数的值。如代码清单所示，在使用identity方法的时候只需要传入方法句柄的唯一参数的类型即可，该方法句柄的返回值类型和参数类型是相同的。<br>MethodHandles类的identity方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">identity</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandle mh = MethodHandles.identity(String.class);</span><br><span class="line">    String value = (String) mh.invoke(<span class="string">"Hello"</span>); <span class="comment">//值为"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而方法constant的作用则更加简单，在生成的时候指定一个常量值，以后这个方法句柄被调用的时候，总是返回这个常量值，在调用时也不需要提供任何参数。这个方法提供了一种把一个常量值转换成方法句柄的方式，如下面的代码所示。在调用constant方法的时候，只需要提供常量的类型和值即可。<br>MethodHandles类的constant方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constant</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandle mh = MethodHandles.constant(String.class, <span class="string">"Hello"</span>);</span><br><span class="line">    String value = (String) mh.invoke(); <span class="comment">//值为"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MethodHandles类中的identity方法和constant方法的作用类似于在开发中用到的“空对象（Null object）”模式的应用。在使用方法句柄的某些场合中，如果没有合适的方法句柄对象，可能不允许直接用null来替换，这个时候可以通过这两个方法来生成简单无害的方法句柄对象作为替代。</p>
<h5 id="方法句柄变换"><a href="#方法句柄变换" class="headerlink" title="方法句柄变换"></a>方法句柄变换</h5><p>方法句柄的强大之处在于可以对它进行各种不同的变换操作。这些变换操作包括对方法句柄的返回值和参数的处理等，同时这些单个的变换操作可以组合起来，形成复杂的变换过程。所有的这些变换方法都是MethodHandles类中的静态方法。这些方法一般接受一个已有的方法句柄对象作为变换的来源，而方法的返回值则是变换操作之后得到的新的方法句柄。下面的内容中经常出现的“原始方法句柄”表示的是变换之前的方法句柄，而“新方法句柄”则表示变换之后的方法句柄。</p>
<p>首先介绍对参数进行处理的变换方法。在调用变换之后的新方法句柄时，调用时的参数值会经过一定的变换操作之后，再传递给原始的方法句柄来完成具体的执行。</p>
<p>第一个方法dropArguments可以在一个方法句柄的参数中添加一些无用的参数。这些参数虽然在实际调用时不会被使用，但是它们可以使变换之后的方法句柄的参数类型格式符合某些所需的特定模式。这也是这种变换方式的主要应用场景。</p>
<p>如代码清单所示，原始的方法句柄mhOld引用的是String类中的substring方法，其类型是String类的返回值加上两个int类型的参数。在调用dropArguments方法的时候，第一个参数表示待变换的方法句柄，第二个参数指定的是要添加的新参数类型在原始参数列表中的起始位置，其后的多个参数类型将被添加到参数列表中。新的方法句柄mhNew的参数类型变为float、String、String、int和int，而在实际调用时，前面两个参数的值会被忽略掉。可以把这些多余的参数理解成特殊调用模式所需要的占位符。<br>dropArguments方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dropArguments</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();   </span><br><span class="line">    MethodType type = MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhOld = lookup.findVirtual(String.class, <span class="string">"substring"</span>, type);</span><br><span class="line">    String value = (String) mhOld.invoke(<span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    MethodHandle mhNew = MethodHandles.dropArguments(mhOld, <span class="number">0</span>, <span class="keyword">float</span>.class, String.class);</span><br><span class="line">    value = (String) mhNew.invoke(<span class="number">0.5f</span>, <span class="string">"Ignore"</span>, <span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个方法insertArguments的作用与本小节前面提到的MethodHandle的bindTo方法类似，但是此方法的功能更加强大。这个方法可以同时为方法句柄中的多个参数预先绑定具体的值。在得到的新方法句柄中，已经绑定了具体值的参数不再需要提供，也不会出现在参数列表中。</p>
<p>在代码清单中，方法句柄mhOld所表示的底层方法是String类中的concat方法。在调用insertArguments方法的时候，与上面的dropArguments方法类似，从第二个参数所指定的参数列表中的位置开始，用其后的可变长度的参数的值作为预设值，分别绑定到对应的参数上。在这里把mhOld的第二个参数的值预设成了固定值“–”，其作用是在调用新方法句柄时，只需要传入一个参数即可，相当于总是与“–”进行字符串连接操作，即使用“–”作为后缀。由于有一个参数被预先设置了值，因此mhNew在调用时只需要一个参数即可。如果预先绑定的是方法句柄mhOld的第一个参数，那就相当于用字符串“–”来连接各种不同的字符串，即为字符串添加“–”作为前缀。如果insertArguments方法调用时指定了多个绑定值，会按照第二个参数指定的起始位置，依次进行绑定。<br>insertArguments方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertArguments</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(String.class, String.class);</span><br><span class="line">    MethodHandle mhOld = lookup.findVirtual(String.class, <span class="string">"concat"</span>, type);</span><br><span class="line">    String value = (String) mhOld.invoke(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">    MethodHandle mhNew = MethodHandles.insertArguments(mhOld, <span class="number">1</span>, <span class="string">" --"</span>);</span><br><span class="line">    value = (String) mhNew.invoke(<span class="string">"Hello"</span>); <span class="comment">//值为“Hello--”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三个方法filterArguments的作用是可以对方法句柄调用时的参数进行预处理，再把预处理的结果作为实际调用时的参数。预处理的过程是通过其他的方法句柄来完成的。可以对一个或多个参数指定用来进行处理的方法句柄。代码清单给出了filterArguments方法的使用示例。要执行的原始方法句柄所引用的是Math类中的max方法，而在实际调用时传入的却是两个字符串类型的参数。中间的参数预处理是通过方法句柄mhGetLength来完成的，该方法句柄的作用是获得字符串的长度。这样就可以把字符串类型的参数转换成原始方法句柄所需要的整数类型。完成预处理之后，将处理的结果交给原始方法句柄来完成调用。<br>filterArguments方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterArguments</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhGetLength = lookup.findVirtual(String.class, <span class="string">"length"</span>, MethodType.methodType(<span class="keyword">int</span>.class));</span><br><span class="line">    MethodHandle mhTarget = lookup.findStatic(Math.class, <span class="string">"max"</span>, type);</span><br><span class="line">    MethodHandle mhNew = MethodHandles.filterArguments(mhTarget, <span class="number">0</span>, mhGetLength, mhGetLength);</span><br><span class="line">    <span class="keyword">int</span> value = (<span class="keyword">int</span>) mhNew.invoke(<span class="string">"Hello"</span>, <span class="string">"New World"</span>); <span class="comment">//值为9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用filterArguments的时候，第二个参数和后面的可变长度的方法句柄参数是配合起来使用的。第二个参数指定的是进行预处理的方法句柄需要处理的参数在参数列表中的起始位置。紧跟在后面的是一系列对应的完成参数预处理的方法句柄。方法句柄与它要处理的参数是一一对应的。如果希望跳过某些参数不进行处理，可以使用null作为方法句柄的值。在进行预处理的时候，要注意预处理方法句柄和原始方法句柄之间的类型匹配。如果预处理方法句柄用于对某个参数进行处理，那么该方法句柄只能有一个参数，而且参数的类型必须匹配所要处理的参数的类型；其返回值类型需要匹配原始方法句柄中对应的参数类型。只有类型匹配，才能用方法句柄对实际传入的参数进行预处理，再把预处理的结果作为原始方法句柄调用时的参数来使用。</p>
<p>第四个方法foldArguments的作用与filterArguments很类似，都是用来对参数进行预处理的。不同之处在于，foldArguments对参数进行预处理之后的结果，不是替换掉原始的参数值，而是添加到原始参数列表的前面，作为一个新的参数。当然，如果参数预处理的返回值是void，则不会添加新的参数。另外，参数预处理是由一个方法句柄完成的，而不是像filterArguments那样可以由多个方法句柄来完成。这个方法句柄会负责处理根据它的类型确定的所有可用参数。下面先看一下具体的使用示例。代码清单2-54中原始的方法句柄引用的是静态方法targetMethod，而用来对参数进行预处理的方法句柄mhCombiner引用的是Math类中的max方法。变换之后的新方法句柄mhResult在被调用时，两个参数3和4首先被传递给句柄mhCombiner所引用的Math.max方法，返回值是4。这个返回值被添加到原始调用参数列表的前面，即得到新的参数列表4、3、4。这个新的参数列表会在调用时被传递给原始方法句柄mhTarget所引用的targetMethod方法。<br>foldArguments方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">targetMethod</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foldArguments</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType typeCombiner = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhCombiner = lookup.findStatic(Math.class, <span class="string">"max"</span>, typeCombiner);</span><br><span class="line">    MethodType typeTarget = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhTarget = lookup.findStatic(Transform.class, <span class="string">"targetMethod"</span>, typeTarget);</span><br><span class="line">    MethodHandle mhResult = MethodHandles.foldArguments(mhTarget, mhCombiner);</span><br><span class="line">    <span class="keyword">int</span> value = (<span class="keyword">int</span>) mhResult.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//输出为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行参数预处理的方法句柄会根据其类型中参数的个数N，从实际调用的参数列表中获取前面N个参数作为它需要处理的参数。如果预处理的方法句柄有返回值，返回值的类型需要与原始方法句柄的第一个参数的类型匹配。这是因为返回值会被作为调用原始方法句柄时的第一个参数来使用。</p>
<p>第五个方法permuteArguments的作用是对调用时的参数顺序进行重新排列，再传递给原始的方法句柄来完成调用。这种排列既可以是真正意义上的全排列，即所有的参数都在重新排列之后的顺序中出现；也可以是仅出现部分参数，没有出现的参数将被忽略；还可以重复某些参数，让这些参数在实际调用中出现多次。代码清单2-55给出了一个对参数进行完全排列的示例。代码中的原始方法句柄mhCompare所引用的是Integer类中的compare方法。当使用参数3和4进行调用的时候，返回值是–1。通过permuteArguments方法把参数的排列顺序进行颠倒，得到了新的方法句柄mhNew。再用同样的参数调用方法句柄mhNew时，返回结果就变成了1，因为传递给底层compare方法的实际调用参数变成了4和3。新方法句柄mhDuplicateArgs在通过permuteArguments方法进行变换的时候，重复了第二个参数，因此传递给底层compare方法的实际调用参数是4和4，返回的结果是0。<br>permuteArguments方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permuteArguments</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhCompare = lookup.findStatic(Integer.class, <span class="string">"compare"</span>, type);</span><br><span class="line">    <span class="keyword">int</span> value = (<span class="keyword">int</span>) mhCompare.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//值为-1</span></span><br><span class="line">    MethodHandle mhNew = MethodHandles.permuteArguments(mhCompare, type, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    value = (<span class="keyword">int</span>) mhNew.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//值为1</span></span><br><span class="line">    MethodHandle mhDuplicateArgs = MethodHandles.permuteArguments(mhCompare, type, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    value = (<span class="keyword">int</span>) mhDuplicateArgs.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里还要着重介绍一下permuteArguments方法的参数。第二个参数表示的是重新排列完成之后的新方法句柄的类型。紧接着的是多个用来表示新的排列顺序的整数。这些整数的个数必须与原始句柄的参数个数相同。整数出现的位置及其值就表示了在排列顺序上的对应关系。比如在上面的代码中，创建方法句柄mhNew的第一个整数参数是1，这就表示调用原始方法句柄时的第一个参数的值实际上是调用新方法句柄时的第二个参数（编号从0开始，1表示第二个）。</p>
<p>第六个方法catchException与原始方法句柄调用时的异常处理有关。可以通过该方法为原始方法句柄指定处理特定异常的方法句柄。如果原始方法句柄的调用正常完成，则返回其结果；如果出现了特定的异常，则处理异常的方法句柄会被调用。通过该方法可以实现通用的异常处理逻辑。可以对程序中可能出现的异常都提供一个进行处理的方法句柄，再通过catchException方法来封装原始的方法句柄。</p>
<p>如代码清单2-56所示，原始的方法句柄mhParseInt所引用的是Integer类中的parseInt方法，这个方法在字符串无法被解析成数字时会抛出java.lang.Number-FormatException。用来进行异常处理的方法句柄是mhHandler，它引用了当前类中的handleException方法。通过catchException得到的新方法句柄mh在被调用时，如果抛出了NumberFormatException，则会调用handleException方法。<br>catchException方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">handleException</span><span class="params">(Exception e, String str)</span> </span>&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchExceptions</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType typeTarget = MethodType.methodType(<span class="keyword">int</span>.class, String.class);</span><br><span class="line">    MethodHandle mhParseInt = lookup.findStatic(Integer.class, <span class="string">"parseInt"</span>, typeTarget);</span><br><span class="line">    MethodType typeHandler = MethodType.methodType(<span class="keyword">int</span>.class, Exception.class, String.class);</span><br><span class="line">    MethodHandle mhHandler = lookup.findVirtual(Transform.class, <span class="string">"handleException"</span>, typeHandler).bindTo(<span class="keyword">this</span>);</span><br><span class="line">    MethodHandle mh = MethodHandles.catchException(mhParseInt, NumberFormatException.class, mhHandler);</span><br><span class="line">    mh.invoke(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里需要注意几个细节：原始方法句柄和异常处理方法句柄的返回值类型必须是相同的，这是因为当产生异常的时候，异常处理方法句柄的返回值会作为调用的结果；而在两个方法句柄的参数方面，异常处理方法句柄的第一个参数是它所处理的异常类型，其他参数与原始方法句柄的参数相同。在异常处理方法句柄被调用的时候，其对应的底层方法可以得到原始方法句柄调用时的实际参数值。在上面的例子中，当handleException方法被调用的时候，参数e的值是NumberFormatException类的对象，参数str的值是原始的调用值“Hello”；在获得异常处理方法句柄的时候，使用了bindTo方法。这是因为通过findVirtual找到的方法句柄的第一个参数类型表示的是方法调用的接收者，这与catchException要求的第一个参数必须是异常类型的约束不相符，因此通过bindTo方法来为第一个参数预先绑定值。这样就可以得到所需的正确的方法句柄。当然，如果异常处理方法句柄所引用的是静态方法，就不存在这个问题。</p>
<p>最后一个在对方法句柄进行变换时与参数相关的方法是guardWithTest。这个方法可以实现在方法句柄这个层次上的条件判断的语义，相当于if-else语句。使用guardWithTest时需要提供3个不同的方法句柄：第一个方法句柄用来进行条件判断，而剩下的两个方法句柄则分别在条件成立和不成立的时候被调用。用来进行条件判断的方法句柄的返回值类型必须是布尔型，而另外两个方法句柄的类型则必须一致，同时也是生成的新方法句柄的类型。</p>
<p>如代码清单2-57所示，进行条件判断的方法句柄mhTest引用的是静态guardTest方法，在条件成立和不成立的时候调用的方法句柄则分别引用了Math类中的max方法和min方法。由于guardTest方法的返回值是随机为true或false的，所以两个方法句柄的调用也是随机选择的。<br>guardWithTest方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">guardTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &gt; <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guardWithTest</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mhTest = lookup.findStatic(Transform.class, <span class="string">"guardTest"</span>, MethodType.methodType(<span class="keyword">boolean</span>.class));</span><br><span class="line">    MethodType type = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhTarget = lookup.findStatic(Math.class, <span class="string">"max"</span>, type);</span><br><span class="line">    MethodHandle mhFallback = lookup.findStatic(Math.class, <span class="string">"min"</span>, type);</span><br><span class="line">    MethodHandle mh = MethodHandles.guardWithTest(mhTest, mhTarget, mhFallback);</span><br><span class="line">    <span class="keyword">int</span> value = (<span class="keyword">int</span>) mh.invoke(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">//值随机为3或5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了可以在变换的时候对方法句柄的参数进行处理之外，还可以对方法句柄被调用后的返回值进行修改。对返回值进行处理是通过filterReturnValue方法来实现的。原始的方法句柄被调用之后的结果会被传递给另外一个方法句柄进行再次处理，处理之后的结果被返回给调用者。代码清单2-58展示了filterReturnValue的用法。原始的方法句柄mhSubstring所引用的是String类的substring方法，对返回值进行处理的方法句柄mhUpperCase所引用的是String类的toUpperCase方法。通过filterReturnValue方法得到的新方法句柄的运行效果是将调用substring得到的子字符串转换成大写的形式。<br>filterReturnValue方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterReturnValue</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mhSubstring = lookup.findVirtual(String.class, <span class="string">"substring"</span>, MethodType.methodType(String.class, <span class="keyword">int</span>.class));</span><br><span class="line">    MethodHandle mhUpperCase = lookup.findVirtual(String.class, <span class="string">"toUpperCase"</span>, MethodType.methodType(String.class));</span><br><span class="line">    MethodHandle mh = MethodHandles.filterReturnValue(mhSubstring, mhUpperCase);</span><br><span class="line">    String str = (String) mh.invoke(<span class="string">"Hello World"</span>, <span class="number">5</span>); <span class="comment">//输出 WORLD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="特殊方法句柄"><a href="#特殊方法句柄" class="headerlink" title="特殊方法句柄"></a>特殊方法句柄</h5><p>在有些情况下，可能会需要对一组类型相同的方法句柄进行同样的变换操作。这个时候与其对所有的方法句柄都进行重复变换，不如创建出一个可以用来调用其他方法句柄的方法句柄。这种特殊的方法句柄的invoke方法或invokeExact方法被调用的时候，可以指定另外一个类型匹配的方法句柄作为实际调用的方法句柄。因为调用方法句柄时可以使用invoke和invokeExact两种方法，对应有两种创建这种特殊的方法句柄的方式，分别通过MethodHandles类的invoker和exactInvoker实现。两个方法都接受一个MethodType对象作为被调用的方法句柄的类型参数，两者的区别只在于调用时候的行为是类似于invoke还是invokeExact。</p>
<p>代码清单2-59给出了invoker方法的使用示例。首先invoker方法句柄可以调用的方法句柄类型的返回值类型为String，加上3个类型分别为Object、int和int的参数。两个被调用的方法句柄，其中一个引用的是String类中的substring方法，另外一个引用的是当前类中的testMethod方法。这两个方法都可以通过invoke方法来正确调用。<br>invoker方法的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoker</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodType typeInvoker = MethodType.methodType(String.class, Object.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle invoker = MethodHandles.invoker(typeInvoker);</span><br><span class="line">    MethodType typeFind = MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);   </span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh1 = lookup.findVirtual(String.class, <span class="string">"substring"</span>, typeFind);</span><br><span class="line">    MethodHandle mh2 = lookup.findVirtual(InvokerUsage.class, <span class="string">"testMethod"</span>, typeFind);</span><br><span class="line">    String result = (String) invoker.invoke(mh1, <span class="string">"Hello"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    result = (String) invoker.invoke(mh2, <span class="keyword">this</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而exactInvoker的使用与invoker非常类似，这里就不举例说明了。</p>
<p>上面提到了使用invoker和exactInvoker的一个重要好处就是在对这个方法句柄进行变换之后，所得到的新方法句柄在调用其他方法句柄的时候，这些变换操作都会被自动地引用，而不需要对每个所调用的方法句柄再单独应用。如代码清单2-60所示，通过filterReturnValue为通过exactInvoker得到的方法句柄添加变换操作，当调用方法句柄mh1的时候，这个变换会被自动应用，使作为调用结果的字符串自动变成大写形式。<br>invoker和exactInvoker对方法句柄变换的影响<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokerTransform</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodType typeInvoker = MethodType.methodType(String.class, String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle invoker = MethodHandles.exactInvoker(typeInvoker);</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mhUpperCase = lookup.findVirtual(String.class, <span class="string">"toUpperCase"</span>, MethodType.methodType(String.class));</span><br><span class="line">    invoker = MethodHandles.filterReturnValue(invoker, mhUpperCase);</span><br><span class="line">    MethodType typeFind = MethodType.methodType(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mh1 = lookup.findVirtual(String.class, <span class="string">"substring"</span>, typeFind);</span><br><span class="line">    String result = (String) invoker.invoke(mh1, <span class="string">"Hello"</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">//值为“ELL”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过invoker方法和exactInvoker方法得到的方法句柄被称为“元方法句柄”，具有调用其他方法句柄的能力。</p>
<h5 id="使用方法句柄实现接口"><a href="#使用方法句柄实现接口" class="headerlink" title="使用方法句柄实现接口"></a>使用方法句柄实现接口</h5><p>动态代理机制可以在运行时为多个接口动态创建实现类，并拦截通过接口进行的方法调用。方法句柄也具备动态实现一个接口的能力。这是通过java.lang.invoke.MethodHandleProxies类中的静态方法asInterfaceInstance来实现的。不过通过方法句柄来实现接口所受的限制比较多。首先该接口必须是公开的，其次该接口只能包含一个名称唯一的方法。这样限制是因为只有一个方法句柄用来处理方法调用。调用asInterfaceInstance方法时需要两个参数，第一个参数是要实现的接口类，第二个参数是处理方法调用逻辑的方法句柄对象。方法的返回值是一个实现了该接口的对象。当调用接口的方法时，这个调用会被代理给方法句柄来完成。方法句柄的返回值作为接口调用的返回值。接口的方法类型与方法句柄的类型必须是兼容的，否则会出现异常。</p>
<p>代码清单2-61是使用方法句柄实现接口的示例。被代理的接口是java.lang.Runnable，其中仅包含一个run方法。实现接口的方法句柄引用的是当前类中的doSomething方法。在调用asInterfaceInstance之后得到的Runnable接口的实现对象被用来创建一个新的线程。该线程运行之后发现doSomething方法会被调用。这是由于当Runnable接口的run方法被调用的时候，方法句柄mh也会被调用。<br>使用方法句柄实现接口的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"WORK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useMethodHandleProxy</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodHandle mh = lookup.findVirtual(UseMethodHandleProxies.class, <span class="string">"doSomething"</span>, MethodType.methodType(<span class="keyword">void</span>.class));</span><br><span class="line">    mh = mh.bindTo(<span class="keyword">this</span>);</span><br><span class="line">    Runnable runnable = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过方法句柄来实现接口的优势在于不需要新建额外的Java类，只需要复用已有的方法即可。在上面的示例中，任何已有的不带参数和返回值的方法都可以用来实现Runnable接口。需要注意的是，要求接口所包含的方法的名称唯一，不考虑Object类中的方法。实际的方法个数可能不止一个，可能包含同一方法的不同重载形式。</p>
<h5 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h5><p>在通过查找已有类中的方法得到方法句柄时，要受限于Java语言中已有的访问控制权限。方法句柄与反射API在访问控制权限上的一个重要区别在于，在每次调用反射API的Method类的invoke方法的时候都需要检查访问控制权限，而方法句柄只在查找的时候需要进行检查。只要在查找过程中不出现问题，方法句柄在使用中就不会出现与访问控制权限相关的问题。这种实现方式也使方法句柄在调用时的性能要优于Method类。</p>
<p>之前介绍过，通过MethodHandles.Lookup类的方法可以查找类中已有的方法以得到MethodHandle对象。而MethodHandles.Lookup类的对象本身则是通过MethodHandles类的静态方法lookup得到的。在Lookup对象被创建的时候，会记录下当前所在的类（称为查找类）。只要查找类能够访问某个方法或域，就可以通过Lookup的方法来查找到对应的方法句柄。代码清单给出了一个访问控制权限相关的示例。AccessControl类中的accessControl方法返回了引用其中私有方法privateMethod的方法句柄。由于当前查找类可以访问该私有方法，因此查找过程是成功的。其他类通过调用accessControl得到的方法句柄就可以调用这个私有方法。虽然其他类不能直接访问AccessControl类中的私有方法，但是在调用方法句柄的时候不会进行访问控制权限检查，因此对方法句柄的调用可以成功进行。<br>方法句柄查找时的访问控制权限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"PRIVATE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodHandle <span class="title">accessControl</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodHandle mh = lookup.findSpecial(AccessControl.class, <span class="string">"privateMethod"</span>, MethodType.methodType(<span class="keyword">void</span>.class), AccessControl.class);</span><br><span class="line">        mh = mh.bindTo(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> mh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="交换点"><a href="#交换点" class="headerlink" title="交换点"></a>交换点</h5><p>交换点是在多线程环境下控制方法句柄的一个开关。这个开关只有两个状态：有效和无效。交换点初始时处于有效状态，一旦从有效状态变到无效状态，就无法再继续改变状态。也就是说，只允许发生一次状态改变。这种状态变化是全局和即时生效的。使用同一个交换点的多个线程会即时观察到状态变化。交换点用java.lang.invoke.SwitchPoint类来表示。通过SwitchPoint对象的guardWithTest方法可以设置在交换点的不同状态下调用不同的方法句柄。这个方法的作用类似于MethodHandles类中的guardWithTest方法，只不过少了用来进行条件判断的方法句柄，只有条件成立和不成立时分别调用的方法句柄。这是因为选择哪个方法句柄来执行是由交换点的有效状态来决定的，不需要额外的条件判断。</p>
<p>在代码清单中，在调用guardWithTest方法的时候指定在交换点有效的时候调用方法句柄mhMin，而在无效的时候则调用mhMax。guardWithTest方法的返回值是一个新的方法句柄mhNew。交换点在初始时处于有效状态，因此mhNew在第一次调用时使用的是mhMin，结果为3。在通过invalidateAll方法把交换点设成无效状态之后，再次调用mhNew时实际调用的方法句柄就变成了mhMax，结果为4。<br>交换点的使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useSwitchPoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhMax = lookup.findStatic(Math.class, <span class="string">"max"</span>, type);</span><br><span class="line">    MethodHandle mhMin = lookup.findStatic(Math.class, <span class="string">"min"</span>, type);</span><br><span class="line">    SwitchPoint sp = <span class="keyword">new</span> SwitchPoint();</span><br><span class="line">    MethodHandle mhNew = sp.guardWithTest(mhMin, mhMax);</span><br><span class="line">    mhNew.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//值为3</span></span><br><span class="line">    SwitchPoint.invalidateAll(<span class="keyword">new</span> SwitchPoint[] &#123;sp&#125;);</span><br><span class="line">    mhNew.invoke(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//值为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交换点的一个重要作用是在多线程环境下使用，可以在多个线程中共享同一个交换点对象。当某个线程的交换点状态改变之后，其他线程所使用的guardWithTest方法返回的方法句柄的调用行为就会发生变化。</p>
<h5 id="使用方法句柄进行函数式编程"><a href="#使用方法句柄进行函数式编程" class="headerlink" title="使用方法句柄进行函数式编程"></a>使用方法句柄进行函数式编程</h5><p>通过上面章节对方法句柄的详细介绍可以看出，方法句柄是一个非常灵活的对方法进行操作的轻量级结构。方法句柄的作用类似于在某些语言中出现的函数指针（function pointer）。在程序中，方法句柄可以在对象之间自由传递，不受访问控制权限的限制。方法句柄的这种特性，使得在Java语言中也可以进行函数式编程。下面通过几个具体的示例来进行说明。</p>
<p>第一个示例是对数组进行操作。数组作为一个常见的数据结构，有的编程语言提供了对它进行复杂操作的功能。这些功能中比较常见的是forEach、map和reduce操作等。这些操作的语义并不复杂，forEach是对数组中的每个元素都依次执行某个操作，而map则是把原始数组按照一定的转换过程变成一个新的数组，reduce是把一个数组按照某种规则变成单个元素。这些操作在其他语言中可能比较好实现，而在Java语言中，则需要引入一些接口，由此带来的是繁琐的实现和冗余的代码。有了方法句柄之后，这个实现就变得简单多了。代码清单2-64给出了使用方法句柄的forEach、map和reduce方法的实现。对数组中元素的处理是由一个方法句柄来完成的。对这个方法句柄只有类型的要求，并不限制它所引用的底层方法所在的类或名称。<br>使用方法句柄实现数组操作的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodType typeCallback = MethodType.methodType(Object.class, Object.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Object[] array, MethodHandle handle)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        handle.invoke(array[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] map(Object[] array, MethodHandle handle) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[i] = handle.invoke(array[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">reduce</span><span class="params">(Object[] array, Object initalValue, MethodHandle handle)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object result = initalValue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        result = handle.invoke(result, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子是方法的柯里化（currying）。柯里化的含义是对一个方法的参数值进行预先设置之后，得到一个新的方法。比如一个做加法运算的方法，本来有两个参数，通过柯里化把其中一个参数的值设为5之后，得到的新方法就只有一个参数。新方法的运行结果是用5加上这个唯一的参数的值。通过MethodHandles类中的insertArguments方法可以很容易地实现方法句柄的柯里化。代码清单2-65给出了相关的实现。方法curry负责把一个方法句柄的第一个参数的值设为指定值；add方法就是一般的加法操作；add5方法对引用add的方法句柄进行柯里化，得到新的方法句柄，再调用此方法句柄。<br>使用方法句柄实现的柯里化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title">curry</span><span class="params">(MethodHandle handle, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.insertArguments(handle, <span class="number">0</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add5</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType type = MethodType.methodType(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    MethodHandle mhAdd = lookup.findStatic(Curry.class, <span class="string">"add"</span>, type);</span><br><span class="line">    MethodHandle mh = curry(mhAdd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) mh.invoke(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面给出的这两个示例所实现的功能虽然比较简单，但是反映出了方法句柄在使用时的极大灵活性。配合方法句柄支持的变换操作，可以实现很多有趣和实用的功能。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/07/04/java_methohandler/">java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">剑客爱编程</a></p>
        <p><span>发布时间:</span>2016-07-04, 21:00:36</p>
        <p><span>最后更新:</span>2016-07-04, 21:00:36</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/07/04/java_methohandler/" title="java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）">https://iskylove.github.io/2016/07/04/java_methohandler/</a>
            <span class="copy-path" data-clipboard-text="原文: https://iskylove.github.io/2016/07/04/java_methohandler/　　作者: 剑客爱编程" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/07/06/java_lang_1/">
                    java object 类wait() notify() 以及Thread类 join() yile学习
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/06/30/android_build_apk/">
                    (转)手把手教你AndroidStudio多渠道打包
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法句柄的类型"><span class="toc-number">1.</span> <span class="toc-text">方法句柄的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法句柄的调用"><span class="toc-number">2.</span> <span class="toc-text">方法句柄的调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#参数长度可变的方法句柄"><span class="toc-number">3.</span> <span class="toc-text">参数长度可变的方法句柄</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#参数绑定"><span class="toc-number">4.</span> <span class="toc-text">参数绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取方法句柄"><span class="toc-number">5.</span> <span class="toc-text">获取方法句柄</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法句柄变换"><span class="toc-number">6.</span> <span class="toc-text">方法句柄变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊方法句柄"><span class="toc-number">7.</span> <span class="toc-text">特殊方法句柄</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用方法句柄实现接口"><span class="toc-number">8.</span> <span class="toc-text">使用方法句柄实现接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#访问控制权限"><span class="toc-number">9.</span> <span class="toc-text">访问控制权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#交换点"><span class="toc-number">10.</span> <span class="toc-text">交换点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用方法句柄进行函数式编程"><span class="toc-number">11.</span> <span class="toc-text">使用方法句柄进行函数式编程</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）　| 剑客爱编程　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/07/06/java_lang_1/" title="上一篇: java object 类wait() notify() 以及Thread类 join() yile学习">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/06/30/android_build_apk/" title="下一篇: (转)手把手教你AndroidStudio多渠道打包">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_jni_study_2/">android_jni_study_2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_jni_study_1/">JNI 初探----基本数据类型和开发配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/java_unsafe_and_cas/">java Unsafe与CAS 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/java_interface_callback_thinker/">对Java接口回调的一些内存泄漏优化的想法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/java_freemarket/">(转)利用FreeMarker生成java源代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/java_DynamicProxy/">java 动态代理DynamicProxy学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/react_native_upgrade/">react-native 升级日志----0.39.2版本升级到0.45.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_gralde_shrinkResources_minifyEnabled/">android gradle配置minifyEnabled以及 shrinkResources踩坑记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/react_native_optimize/">react-native 优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_apk_size_reduce/">android减包小工具----gradle任务分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_tinker_andresguard_fit/">android tinker热更与AndResGuard混淆适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_sdk_moudle_debug_release/">(转)Android中使用BuildConfig.DEBUG必须知道的内幕</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_layoutinflater_setFactory/">android layoutinflater里面setFactory的探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/android_apollo_graphql/">graphql浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/java_leakcanary_androidwatchexecutor/">LeakCanary源码学习--内存泄露观察策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/android_addIdleHandler/">android addIdleHandler 空闲线程学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/android_Memory_Management_in_Android/">(转)Hunting Your Leaks, Memory Management in Android</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/java_rxjava/">Rxjava源码学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/java_reference/">java Reference 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/java_leakcanary/">LeakCanary源码学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/java_referencequeue/">深入理解ReferenceQueue GC finalize Reference</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/05/android_patch_fix/"><转>漫谈Android 增量更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/05/java_javassist/">(转)JAVA 字节码操作利器javassist</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/05/android_aop_des/">【翻译】Android中的AOP编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/android_drawable/">(转)领略千变万化的Android Drawable</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/website_share/">技术网站分享(持续更新中~~)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/android_viewpager/">android ViewPager控件深入了解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/android_material_design/">android material design 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/09/java_datastructures_alogorithm_3/">(数据结构与算法分析笔记])第四章  树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/08/java_datastructures_alogorithm_2/">(数据结构与算法分析笔记)第三章  表  栈  队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/08/java_datastructures_alogorithm_1/">(数据结构与算法分析笔记)第二章  算法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/07/java_inner_nested_class/">java嵌套类，内部类，匿名类学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/java_lang_1/">java object 类wait() notify() 以及Thread类 join() yile学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/04/java_methohandler/">java.lanf.invoke.MethodHandles 学习（深入理解Java虚拟机 学习笔记）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/android_build_apk/">(转)手把手教你AndroidStudio多渠道打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/android_view_measure/">android view measure方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/19/android_surface/">(转)android SurfaceView, GLSurfaceView, SurfaceTexture,TextureView</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/android_file_cache/">android getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/java_Introspector/">(转)深入理解Java：内省(Introspector)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/android_appopsmanager/">android AppOpsManager 检查应用权限</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/05/android_broadcast/">android broadcast 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/05/android_animator_favor/">android动画研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/05/java_reflect/">java反射机制学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/04/android_mobile_apk_decompile/">android引导用户开启应用权限及系统apk反编译分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/svnchecker_install/">svnchecker 适配安装以及踩过的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/hexo_install/">hexo + github + 七牛运存储搭建简单的博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/begin_blog/">剑客爱编程--启动篇</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 2017 剑客爱编程
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>